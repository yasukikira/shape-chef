<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shapes & Sorcery: A D&D Adventure Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel+Decorative:wght@400;700&family=Open+Sans&display=swap');
        :root {
            --parchment-bg: #f0e6d2;
            --dark-brown: #3a2b1b;
            --wood-leather-dark: #5a3d2b;
            --parchment-light-bg: #fff9f0;
            --stone-wood-medium: #e0d8c8;
            --border-color: #c8b898;
            --button-bg: #7a5c4b;
            --button-hover-bg: #5a3d2b;
            --danger-bg: #a04040;
            --danger-hover-bg: #803030;
            --text-font: 'Open Sans', sans-serif;
            --heading-font: 'MedievalSharp', cursive;
            --title-font: 'Cinzel Decorative', cursive;
        }
        body {
            font-family: var(--text-font); margin: 0; padding: 0; background-color: var(--parchment-bg); color: var(--dark-brown);
            display: flex; flex-direction: column; min-height: 100vh; font-size: 16px; position: relative;
        }
        header {
            background-color: var(--wood-leather-dark); color: var(--parchment-bg); padding: 10px 20px; text-align: center;
            font-family: var(--title-font); font-size: 1.6em; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 10;
            display: flex; justify-content: center; align-items: center; position: relative;
        }
        header .title-text { flex-grow: 1; }

        #helpButton {
            position: absolute; right: 15px; top: 50%; transform: translateY(-50%);
            background-color: var(--parchment-light-bg); color: var(--wood-leather-dark); border: 1px solid var(--wood-leather-dark);
            border-radius: 50%; width: 35px; height: 35px; font-size: 1.2em; font-weight: bold; cursor: pointer;
            display: flex; justify-content: center; align-items: center; transition: background-color 0.3s, color 0.3s;
        }
        #helpButton:hover { background-color: var(--wood-leather-dark); color: var(--parchment-light-bg); }

        .container { display: flex; flex: 1; padding: 10px; gap: 15px; }
        .main-game-area {
            flex: 3; display: flex; flex-direction: column; background-color: var(--parchment-light-bg);
            padding: 15px; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.1); min-width: 0;
        }
        .sidebar {
            flex: 1; background-color: var(--stone-wood-medium); padding: 15px; border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 15px; min-width: 0;
        }
        h2, h3 {
            font-family: var(--heading-font); color: var(--wood-leather-dark); border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px; margin-top: 0.5em; margin-bottom: 0.8em;
        }
        h2 { font-size: 1.4em; } h3 { font-size: 1.2em; }
        .tabs { display: flex; margin-bottom: 15px; border-bottom: 2px solid var(--wood-leather-dark); flex-wrap: wrap; }
        .tab-button {
            padding: 8px 12px; cursor: pointer; border: none; background-color: transparent; font-family: var(--heading-font);
            font-size: 1em; color: var(--wood-leather-dark); margin-bottom: -2px; flex-grow: 1; text-align: center;
        }
        .tab-button.active {
            background-color: var(--parchment-light-bg); border: 2px solid var(--wood-leather-dark);
            border-bottom: 2px solid var(--parchment-light-bg); border-radius: 6px 6px 0 0;
        }
        .tab-content { display: none; } .tab-content.active { display: block; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; }
        input[type="text"], input[type="password"], textarea {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid var(--border-color);
            border-radius: 4px; background-color: #fdfbf5; font-size: 0.95em;
        }
        textarea { resize: vertical; min-height: 60px; }
        button {
            background-color: var(--button-bg); color: var(--parchment-bg); padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; font-family: var(--text-font);
            transition: background-color 0.3s ease; font-size: 0.95em; width: auto;
        }
        button:hover { background-color: var(--button-hover-bg); }
        button.danger { background-color: var(--danger-bg); }
        button.danger:hover { background-color: var(--danger-hover-bg); }
        button:disabled { background-color: #b0a090; cursor: not-allowed; }
        #scenarioDisplay {
            flex-grow: 1; overflow-y: auto; padding: 10px; border: 1px solid #d8c8a8; border-radius: 4px;
            margin-bottom: 15px; background-color: #fdfbf5; white-space: pre-wrap; min-height: 100px; font-size: 0.95em;
        }
        #scenarioDisplay img, #scenarioDisplay audio {
            max-width: 100%; display: block; margin: 10px auto; border-radius: 4px;
        }
        #scenarioDisplay strong, .chat-message strong { font-weight: bold; } /* Combined for brevity */
        #scenarioDisplay em, .chat-message em { font-style: italic; }
        #scenarioDisplay del, .chat-message del { text-decoration: line-through; }

        #diceDisplayContainer { text-align: center; margin-bottom: 15px; }
        #diceDisplay {
            display: inline-block; width: 50px; height: 50px; line-height: 50px; border: 2px solid var(--wood-leather-dark);
            border-radius: 8px; font-size: 1.5em; font-weight: bold; font-family: var(--heading-font);
            background-color: #fff; color: var(--dark-brown);
        }
        #chatLog {
            height: 150px; overflow-y: auto; border: 1px solid #d8c8a8; padding: 10px; margin-bottom: 15px;
            background-color: #fdfbf5; border-radius: 4px; font-size: 0.9em;
        }
        .chat-message {
            padding: 6px; margin-bottom: 6px; border-radius: 4px; position: relative; word-wrap: break-word;
        }
        .chat-message img, .chat-message audio { max-width: 80%; display: block; margin: 5px 0; border-radius: 3px; }
        .chat-message audio { width: 100%; } 

        .chat-message .actions { position: absolute; top: 2px; right: 5px; display: none; opacity: 0.8; }
        .chat-message:hover .actions { display: flex; gap: 3px; } /* Use flex for better alignment */
        .chat-message .actions button { font-size: 0.75em; padding: 1px 3px; margin-left: 0px; background-color: rgba(200, 184, 152, 0.7); border:1px solid var(--dark-brown); color: var(--dark-brown); }
        .chat-message .actions button:hover { background-color: var(--stone-wood-medium); }


        .user-message { background-color: #e8f0f4; text-align: right; }
        .shape-message { background-color: #fdecd0; }
        .message-role { font-weight: bold; font-size: 0.9em; color: var(--wood-leather-dark); }
        #userInputArea { display: flex; gap: 10px; align-items: stretch; }
        #userInputArea textarea { flex-grow: 1; min-height: 40px; height: auto; max-height: 100px; margin-bottom: 0; }
        #userInputArea button { flex-shrink: 0; }
        .shape-card {
            background-color: #fdfbf5; padding: 10px; border: 1px solid var(--border-color);
            border-radius: 6px; margin-bottom: 10px;
        }
        .shape-card h4 { margin-top: 0; margin-bottom: 8px; font-family: var(--heading-font); font-size: 1.1em; }
        .shape-card .api-key-display { font-size: 0.8em; color: #777; word-break: break-all; }
        .shape-card.active-shape { border-left: 5px solid var(--button-bg); background-color: #fff5e8; }
        .shape-card-actions button { margin-right: 5px; margin-top: 5px; font-size: 0.85em; padding: 6px 10px; }
        .shape-card-actions { display: flex; flex-wrap: wrap; gap: 5px; }
        .api-status { text-align: center; margin-top: 10px; font-style: italic; color: #777; font-size: 0.85em; }
        
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.6); 
        }
        .modal-content {
            background-color: var(--parchment-light-bg); margin: 10% auto; padding: 25px; border: 3px solid var(--wood-leather-dark);
            border-radius: 10px; width: 80%; max-width: 700px; color: var(--dark-brown);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); font-size: 0.95em; max-height: 80vh; overflow-y: auto;
        }
        .modal-content h4 {
            font-family: var(--title-font); color: var(--wood-leather-dark); margin-top: 0; font-size: 1.5em;
            border-bottom: 1px solid var(--border-color); padding-bottom: 10px;
        }
        .modal-content ul { list-style-type: disc; margin-left: 20px; }
        .modal-content li { margin-bottom: 8px; }
        .modal-content code { background-color: var(--stone-wood-medium); padding: 2px 5px; border-radius: 3px; font-family: monospace;}
        .close-button { color: var(--danger-bg); float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: var(--danger-hover-bg); text-decoration: none; cursor: pointer; }

        @media (min-width: 769px) {
            .container { padding: 20px; gap: 20px; }
            .main-game-area, .sidebar { padding: 20px; }
            #chatLog { height: 200px; }
            #userInputArea textarea { max-height: 120px; }
            header { font-size: 1.8em; }
            .tab-button { padding: 10px 15px; font-size: 1.1em; }
        }
        @media (max-width: 768px) {
            body { font-size: 15px; }
            .container { flex-direction: column; }
            .main-game-area, .sidebar { flex: none; width: 100%; box-sizing: border-box; }
            header { font-size: 1.4em; padding: 10px 15px; }
            h2 { font-size: 1.3em; } h3 { font-size: 1.1em; }
            #userInputArea { flex-direction: column; }
            #userInputArea textarea { width: calc(100% - 22px); margin-bottom: 10px; }
            #userInputArea button { width: 100%; }
            .tabs { justify-content: space-around; }
            .tab-button { flex-basis: 45%; margin-bottom: 5px; }
            .modal-content { margin: 15% auto; width: 90%; padding: 20px;}
            #helpButton { width: 30px; height: 30px; font-size: 1em; right: 10px;}
        }
        @media (max-width: 480px) {
            body { font-size: 14px; }
            header { font-size: 1.2em; }
            .tab-button { font-size: 0.9em; padding: 6px 8px; }
            #diceDisplay { width: 45px; height: 45px; line-height: 45px; font-size: 1.3em; }
            .shape-card-actions button { width: 100%; margin-right: 0; }
            .shape-card-actions { flex-direction: column; }
            .modal-content { margin: 5% auto; width: 90%; padding: 15px; font-size: 0.9em; }
            .modal-content h4 { font-size: 1.3em; }
        }
    </style>
</head>
<body>
    <header>
        <span class="title-text">Shapes & Sorcery</span>
        <button id="helpButton" title="Open Game Guide">?</button>
    </header>

    <div id="guideModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeGuideModal">&times;</span>
            <h4>Shapes & Sorcery - Player's Guide</h4>
            <p>Welcome, adventurer! Here's how to interact with your Dungeon Master (DM) and the game world:</p>
            
            <h5>Interacting with the World:</h5>
            <ul>
                <li><strong>Describing Actions:</strong> When you want your character to do something, type it naturally. For actions where success isn't guaranteed (e.g., attacking, picking a lock, persuading someone), try to be clear. A D20 dice will roll automatically for such actions. The DM will be aware of your character's current stats.</li>
                <li>The DM's responses may include basic formatting like <strong>**bold**</strong>, <em>*italic*</em>, or <del>~~strikethrough~~</del>.</li>
                <li><strong>Examples of Action Phrases that might trigger a dice roll:</strong>
                    <ul>
                        <li><code>I try to open the chest</code></li>
                        <li><code>I attack the goblin with my sword</code></li>
                        <li><code>I attempt to persuade the guard</code></li>
                    </ul>
                </li>
                <li><strong>Phrases often indicating an action that will trigger a dice roll start with:</strong>
                    <code>i try to</code>, <code>i attempt to</code>, <code>i attack</code>, <code>i cast</code>, <code>i search</code>, <code>i pick</code>, <code>i climb</code>, <code>i jump</code>, <code>i sneak</code>, <code>i persuade</code>, <code>i intimidate</code>, <code>i deceive</code>, <code>i use my</code>, <code>i look for</code>, <code>i investigate</code>, <code>i disable</code>, <code>i open the</code>, <code>i move to</code>.
                </li>
                 <li><strong>Talking & Observing:</strong> If you're just talking to a character, asking the DM a question about the environment, or making a general observation, a dice roll usually won't happen. The DM will respond, and might then ask you to make a roll if your statement leads to a risky action.</li>
                 <li><strong>Phrases for observation/statements that usually don't trigger an immediate roll start with:</strong>
                    <code>i look at</code>, <code>i see</code>, <code>i think</code>, <code>i say</code>, <code>i go to</code>, <code>i walk to</code>, <code>i head towards</code>.
                </li>
            </ul>

            <h5>Special Commands (Type these in the input box):</h5>
            <ul>
                <li><code>!stats</code>: View your character's randomly generated ability scores for the current adventure.</li>
                <li><code>!ask [your question]</code>: Ask an out-of-character (OOC) question directly to the game AI (the Shape). The AI will respond using its base personality.</li>
                <li><code>!reset</code>: Resets the DM's long-term memory and your character stats for a new adventure with the current DM.</li>
                <li><code>!wack</code>: Resets the DM's short-term memory.</li>
                <li><code>!imagine [description]</code>: Ask the DM to generate an image.</li>
                <li><code>!web [search query]</code>: Ask the shape to search the web.</li>
                <li><code>!info</code>: Get information about the current Shape.</li>
                <li><code>!dashboard</code>: Access the Shape's configuration dashboard at shapes, inc.</li>
                <li><code>!sleep</code>: Saves conversation as an instant memory card.</li>
                <li><code>!help</code>: Ask the Shape for a list of its supported commands.</li>
            </ul>
             <h5>Tips for a Great Adventure:</h5>
            <ul>
                <li>Be descriptive! The more the shape knows, the better it can respond.</li>
                <li>Use the <code>!ask</code> command if you're unsure about game rules or possibilities.</li>
                <li>Have fun!</li>
            </ul>
        </div>
    </div>

    <div class="container">
        <div class="main-game-area">
            <h2>The Adventure Unfolds...</h2>
            <div id="scenarioDisplay">
                Welcome, brave adventurer! Please enter your Shapes API Key and an initial DM Shape Username in the Settings tab to begin.
            </div>
            <div id="diceDisplayContainer">
                <div id="diceDisplay">D20</div>
            </div>
            <h3>Chat Log</h3>
            <div id="chatLog"></div>
            <div id="userInputArea">
                <textarea id="playerInput" placeholder="What do you do? (e.g., 'I try to open the chest' or '!reset')" rows="1"></textarea>
                <button id="sendActionBtn">Send</button>
            </div>
            <div id="apiStatus" class="api-status">API Ready</div>
        </div>
        <div class="sidebar">
            <div class="tabs">
                <button class="tab-button active" onclick="openTab(event, 'settingsTabContent', this)">Settings</button>
                <button class="tab-button" onclick="openTab(event, 'shapesTabContent', this)">Shapes (DMs)</button>
            </div>
            <div id="settingsTabContent" class="tab-content active">
                <h3>API & Initial DM Configuration</h3>
                <label for="globalApiKey">Global Shapes API Key (used if DM has no specific key):</label>
                <input type="password" id="globalApiKey" placeholder="Enter your Global Shapes API Key">
                <label for="initialShapeUsername">Initial DM's Vanity URL:</label>
                <input type="text" id="initialShapeUsername" placeholder="e.g., Tenshi">
                <label for="initialShapeApiKey">Initial DM's API Key (optional, uses Global if blank):</label>
                <input type="password" id="initialShapeApiKey" placeholder="DM-specific API Key (optional)">
                <button id="saveAndStartBtn">Save & Start Adventure</button>
                <hr style="margin: 20px 0;">
                <button id="hardResetBtn" class="danger">Hard Reset All</button>
            </div>
            <div id="shapesTabContent" class="tab-content">
                <h3>Switch or Add DMs</h3>
                <label for="newShapeUsername">New DM's Vanity URL:</label>
                <input type="text" id="newShapeUsername" placeholder="e.g., AnotherGreatDM">
                <label for="newShapeApiKey">New DM's API Key (optional, uses Global if blank):</label>
                <input type="password" id="newShapeApiKey" placeholder="DM-specific API Key (optional)">
                <button id="addNewDmBtn" style="margin-bottom: 15px; width: 100%;">Add DM to List</button>
                <div id="savedShapesContainer"></div>
            </div>
        </div>
    </div>
    <script>
        const SHAPES_API_BASE_URL = "https://api.shapes.inc/v1/";
        const API_CALL_INTERVAL_MS = 12000; 
        let globalApiKey = ''; // Changed from apiKey to globalApiKey
        let activeShapeUsername = '';
        let activeShapeApiKey = ''; // To store the API key of the currently active DM
        let activeShapeId = null; 
        let userId = ''; 
        let currentChannelId = ''; 
        let chatHistory = []; 
        let shapeCatalog = []; // Will now store objects like {id, username, apiKey}
        let lastApiCallTime = 0;
        let isApiBusy = false;

        const scenarioDisplay = document.getElementById('scenarioDisplay');
        const diceDisplay = document.getElementById('diceDisplay');
        const chatLog = document.getElementById('chatLog');
        const playerInput = document.getElementById('playerInput');
        const sendActionBtn = document.getElementById('sendActionBtn');
        const apiStatus = document.getElementById('apiStatus');
        
        const globalApiKeyInput = document.getElementById('globalApiKey'); // New ID
        const initialShapeUsernameInput = document.getElementById('initialShapeUsername');
        const initialShapeApiKeyInput = document.getElementById('initialShapeApiKey'); // New input
        const saveAndStartBtn = document.getElementById('saveAndStartBtn');
        const hardResetBtn = document.getElementById('hardResetBtn');
        
        const newShapeUsernameInput = document.getElementById('newShapeUsername');
        const newShapeApiKeyInput = document.getElementById('newShapeApiKey'); // New input
        const addNewDmBtn = document.getElementById('addNewDmBtn');
        const savedShapesContainer = document.getElementById('savedShapesContainer');
        
        const helpButton = document.getElementById('helpButton');
        const guideModal = document.getElementById('guideModal');
        const closeGuideModal = document.getElementById('closeGuideModal');


        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Will load globalApiKey and shapeCatalog (which includes individual keys)
            renderShapeCards(); 
            updateActiveShapeDisplay(); // Sets activeShapeUsername and activeShapeApiKey if an active DM exists

            if (!userId) {
                userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
                localStorage.setItem('shapesDnd_userId', userId);
            }

            sendActionBtn.addEventListener('click', handleUserAction);
            playerInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUserAction(); }
            });

            saveAndStartBtn.addEventListener('click', () => {
                const newGlobalApiKey = globalApiKeyInput.value.trim();
                const initialDmUsername = initialShapeUsernameInput.value.trim();
                const initialDmApiKey = initialShapeApiKeyInput.value.trim();

                if (!newGlobalApiKey && !initialDmApiKey) {
                    alert('Please enter either a Global API Key or a specific API Key for the Initial DM.');
                    return;
                }
                if (!initialDmUsername) {
                    alert('Please enter an Initial DM Shape Username (Vanity URL).');
                    return;
                }

                globalApiKey = newGlobalApiKey;
                localStorage.setItem('shapesDnd_globalApiKey', globalApiKey);
                
                // Use DM-specific key if provided, else global key for this first DM.
                const firstDmEffectiveApiKey = initialDmApiKey || globalApiKey;
                initializeFirstShapeAndGame(initialDmUsername, firstDmEffectiveApiKey);
                
                initialShapeUsernameInput.value = ''; 
                initialShapeApiKeyInput.value = '';
            });

            hardResetBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to delete ALL data? This includes API keys, shapes, and chat history!')) {
                    localStorage.clear(); 
                    globalApiKey = ''; activeShapeUsername = ''; activeShapeApiKey = ''; activeShapeId = null; userId = ''; 
                    chatHistory = []; shapeCatalog = [];
                    scenarioDisplay.innerHTML = "All data has been reset. Please configure your API key(s) and initial DM in Settings.";
                    globalApiKeyInput.value = ''; initialShapeUsernameInput.value = ''; initialShapeApiKeyInput.value = ''; 
                    newShapeUsernameInput.value = ''; newShapeApiKeyInput.value = '';
                    renderShapeCards(); renderChatLog(); updateActiveShapeDisplay();
                }
            });

            addNewDmBtn.addEventListener('click', () => {
                const newDmUsername = newShapeUsernameInput.value.trim();
                const newDmApiKey = newShapeApiKeyInput.value.trim(); // Can be empty
                if (newDmUsername) {
                    // An API key (either specific or global) must be available to add a DM
                    if (!newDmApiKey && !globalApiKey) {
                        alert("Please set a Global API Key in Settings, or provide a specific key for this DM.");
                        return;
                    }
                    addShapeToCatalog(newDmUsername, newDmApiKey); // Pass API key
                    newShapeUsernameInput.value = ''; 
                    newShapeApiKeyInput.value = '';
                } else {
                    alert("Please enter a username for the new DM.");
                }
            });

            helpButton.addEventListener('click', () => { guideModal.style.display = "block"; });
            closeGuideModal.addEventListener('click', () => { guideModal.style.display = "none"; });
            window.addEventListener('click', (event) => { if (event.target == guideModal) guideModal.style.display = "none"; });

            openTab(null, 'settingsTabContent', document.querySelector('.tab-button[onclick*="settingsTabContent"]'));
            
            if (activeShapeId) { // If returning user with a previously active DM
                 const activeShape = shapeCatalog.find(s => s.id === activeShapeId);
                 if (activeShape) {
                    activeShapeUsername = activeShape.username;
                    activeShapeApiKey = activeShape.apiKey || globalApiKey; // Fallback to global
                    scenarioDisplay.innerHTML = `Welcome back! Active DM: ${activeShapeUsername}. Your adventure awaits. <br><br><b>Tip:</b> Click the <b>?</b> button in the header for game tips and commands!`;
                    loadChatHistory(); 
                 } else { // Active ID was stored, but shape is gone (e.g. catalog cleared partially)
                    activeShapeId = null; // Reset
                    scenarioDisplay.innerHTML += "<br><br><b>Tip:</b> Click the <b>?</b> button in the header for game tips and commands!";
                 }
            } else {
                 scenarioDisplay.innerHTML += "<br><br><b>Tip:</b> Click the <b>?</b> button in the header for game tips and commands!";
            }
        });

        function openTab(event, tabName, buttonEl) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) tabcontent[i].style.display = "none";
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) tablinks[i].className = tablinks[i].className.replace(" active", "");
            document.getElementById(tabName).style.display = "block";
            const currentButton = buttonEl || (event ? event.currentTarget : null);
            if (currentButton) currentButton.className += " active";
        }
        
        function initializeFirstShapeAndGame(dmUsername, dmApiKey) {
            let existingShape = shapeCatalog.find(s => s.username.toLowerCase() === dmUsername.toLowerCase());
            if (!existingShape) {
                const newShape = { id: `shape_${Date.now()}`, username: dmUsername, apiKey: dmApiKey }; // Store API key
                shapeCatalog.push(newShape);
                saveShapeCatalog();
                existingShape = newShape;
            } else { // Update API key if the same DM is re-initialized
                existingShape.apiKey = dmApiKey;
                saveShapeCatalog();
            }
            selectShape(existingShape.id, true); 
        }

        function loadSettings() {
            globalApiKey = localStorage.getItem('shapesDnd_globalApiKey') || '';
            globalApiKeyInput.value = globalApiKey;
            userId = localStorage.getItem('shapesDnd_userId') || '';
            loadShapeCatalog(); // Loads DMs, each potentially with its own API key
            activeShapeId = localStorage.getItem('shapesDnd_activeShapeId') || null;
            
            const storedActiveShape = shapeCatalog.find(s => s.id == activeShapeId);
            if (storedActiveShape) {
                activeShapeUsername = storedActiveShape.username;
                activeShapeApiKey = storedActiveShape.apiKey || globalApiKey; // Use DM's key or fallback to global
            }
        }
        function loadShapeCatalog() {
            const storedCatalog = localStorage.getItem('shapesDnd_shapeCatalog');
            shapeCatalog = storedCatalog ? JSON.parse(storedCatalog) : []; // Shape catalog now stores {id, username, apiKey}
        }
        function saveShapeCatalog() { localStorage.setItem('shapesDnd_shapeCatalog', JSON.stringify(shapeCatalog)); }
        
        function generatePlayerStats() {
            const stats = {};
            const abilities = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"];
            abilities.forEach(ability => { stats[ability] = Math.floor(Math.random() * 11) + 8; });
            return stats;
        }

        function loadChatHistory() {
            if (!activeShapeId || !currentChannelId) { chatHistory = []; renderChatLog(); return; }
            const storedHistory = localStorage.getItem(`shapesDnd_chatHistory_${activeShapeId}_${currentChannelId}`);
            chatHistory = storedHistory ? JSON.parse(storedHistory) : [];
            renderChatLog();
        }
        function saveChatHistory() {
             if (!activeShapeId || !currentChannelId) return;
            localStorage.setItem(`shapesDnd_chatHistory_${activeShapeId}_${currentChannelId}`, JSON.stringify(chatHistory));
        }
        function addShapeToCatalog(username, specificApiKey = '') { // specificApiKey can be empty
            if (!username) return;
            if (shapeCatalog.find(s => s.username.toLowerCase() === username.toLowerCase())) {
                alert("A DM with this username already exists in your list.");
                return;
            }
            const newShape = { id: `shape_${Date.now()}`, username: username, apiKey: specificApiKey };
            shapeCatalog.push(newShape);
            saveShapeCatalog(); renderShapeCards();
            alert(`DM "${username}" added. API Key: ${specificApiKey ? 'Specific key set' : 'Will use Global Key'}.`);
        }
        function renderShapeCards() {
            savedShapesContainer.innerHTML = '';
            if (shapeCatalog.length === 0) {
                savedShapesContainer.innerHTML = '<p style="font-size:0.9em; text-align:center;">No DMs saved yet.</p>';
                return;
            }
            shapeCatalog.forEach(shape => {
                const card = document.createElement('div');
                card.className = 'shape-card';
                if (shape.id === activeShapeId) card.classList.add('active-shape');
                const apiKeyDisplay = shape.apiKey ? 'Specific Key Set' : 'Uses Global Key';
                card.innerHTML = `<h4>${shape.username}</h4> <div class="api-key-display">API Key: ${apiKeyDisplay}</div> <div class="shape-card-actions"><button onclick="selectShape('${shape.id}')">Select DM</button><button onclick="editShape('${shape.id}')">Edit</button><button class="danger" onclick="deleteShape('${shape.id}')">Delete</button></div>`;
                savedShapesContainer.appendChild(card);
            });
        }
        function selectShape(shapeId, isInitialSetup = false) {
            const selected = shapeCatalog.find(s => s.id === shapeId);
            if (selected) {
                activeShapeId = selected.id; 
                activeShapeUsername = selected.username;
                activeShapeApiKey = selected.apiKey || globalApiKey; // Use DM's specific key or fallback to global

                localStorage.setItem('shapesDnd_activeShapeId', activeShapeId);
                currentChannelId = `dnd_game_${activeShapeUsername.replace(/[^a-zA-Z0-9_]/g, '_')}_${Date.now()}`;
                chatHistory = []; 
                
                if (!activeShapeApiKey) { // Critical check: no API key available at all
                     scenarioDisplay.innerHTML = `Cannot start game with ${activeShapeUsername}. No API Key is set for this DM and no Global API Key is available. Please check Settings.`;
                     addMessageToChat('system', `Error: No API Key available for DM ${activeShapeUsername}.`);
                     return; 
                }
                
                scenarioDisplay.innerHTML = `Selected DM: ${activeShapeUsername}. Preparing your adventure...`;
                startGameWithDM(); 
                renderShapeCards(); updateActiveShapeDisplay();
                if (isInitialSetup) { 
                    const dmTabButton = document.querySelector('.tab-button[onclick*="shapesTabContent"]');
                    if (dmTabButton) openTab(null, 'shapesTabContent', dmTabButton);
                }
            }
        }
        function editShape(shapeId) { // Now allows editing username AND their specific API key
            const shapeIndex = shapeCatalog.findIndex(s => s.id === shapeId);
            if (shapeIndex === -1) return;
            
            const shape = shapeCatalog[shapeIndex];
            const newUsername = prompt("Enter new username for this DM (leave blank to keep current):", shape.username);
            const newApiKey = prompt("Enter new specific API Key for this DM (leave blank to use Global Key, or to keep current specific key if one was set):", shape.apiKey || '');

            let changed = false;
            if (newUsername && newUsername.trim() !== "" && newUsername.trim() !== shape.username) {
                if (shapeCatalog.find(s => s.username.toLowerCase() === newUsername.trim().toLowerCase() && s.id !== shapeId)) {
                    alert("Another DM with this username already exists."); return;
                }
                shapeCatalog[shapeIndex].username = newUsername.trim();
                changed = true;
            }
            // Only update apiKey if a new value is explicitly provided or if it's being cleared
            if (newApiKey !== null) { // User didn't cancel the API key prompt
                 if (newApiKey.trim() !== (shapeCatalog[shapeIndex].apiKey || '')) { // Check against current specific key
                    shapeCatalog[shapeIndex].apiKey = newApiKey.trim();
                    changed = true;
                 }
            }

            if (changed) {
                saveShapeCatalog(); renderShapeCards();
                if (shape.id === activeShapeId) { 
                    activeShapeUsername = shapeCatalog[shapeIndex].username;
                    activeShapeApiKey = shapeCatalog[shapeIndex].apiKey || globalApiKey;
                    updateActiveShapeDisplay();
                    scenarioDisplay.innerHTML = `DM details updated for ${activeShapeUsername}. The current adventure context might be affected. Consider using !reset.`;
                }
            }
        }
        function deleteShape(shapeId) {
            const shapeToDelete = shapeCatalog.find(s=>s.id===shapeId);
            if (!shapeToDelete) return;

            if (confirm(`Are you sure you want to delete the DM "${shapeToDelete.username}"?`)) {
                shapeCatalog = shapeCatalog.filter(s => s.id !== shapeId);
                saveShapeCatalog();
                if (activeShapeId === shapeId) {
                    localStorage.removeItem(`shapesDnd_chatHistory_${activeShapeId}_${currentChannelId}`); 
                    localStorage.removeItem(`shapesDnd_playerStats_${activeShapeId}_${currentChannelId}`);
                    activeShapeId = null; activeShapeUsername = ''; activeShapeApiKey = ''; 
                    localStorage.removeItem('shapesDnd_activeShapeId');
                    currentChannelId = ''; scenarioDisplay.innerHTML = "Active DM was deleted. Please select or add a new one.";
                    chatHistory = []; renderChatLog();
                }
                renderShapeCards(); updateActiveShapeDisplay();
            }
        }
        function updateActiveShapeDisplay() {
             const activeShapeInfo = document.querySelector('.main-game-area h2');
             activeShapeInfo.textContent = activeShapeUsername ? `Adventure with ${activeShapeUsername}...` : `The Adventure Unfolds...`;
        }
        async function startGameWithDM() {
            if (!activeShapeApiKey || !activeShapeUsername) { // Use activeShapeApiKey
                scenarioDisplay.innerHTML = "Please set your API key(s) and select an active Shape DM first."; return;
            }
            chatHistory = []; 
            addMessageToChat('system', `Starting new adventure with DM: ${activeShapeUsername}...`);
            const playerStats = generatePlayerStats();
            localStorage.setItem(`shapesDnd_playerStats_${activeShapeId}_${currentChannelId}`, JSON.stringify(playerStats));
            addMessageToChat('system', "New character stats have been generated for this adventure! Use !stats to view them.");
            scenarioDisplay.innerHTML = "The DM is conjuring your world...";
            
            let statsStringForPrompt = "Player's Current Ability Scores (for DM context, do not state these to player unless they ask via !stats):\n";
            for (const [ability, score] of Object.entries(playerStats)) {
                statsStringForPrompt += `${ability}: ${score}\n`;
            }

            const initialPromptObject = {
                role: "user",
                content: `
                ATTENTION! For this session, you will adopt a specific persona for narrating our Dungeons & Dragons game: your DM name is ${activeShapeUsername}.
                However, remember that underneath this DM persona, you are a Shape from shapes.inc, and you have your own unique base personality, memories, and characteristics.
                The Player character for this adventure has the following randomly generated ability scores. You should consider these when narrating outcomes of their actions, but do NOT explicitly state these scores to the player unless they use the \`!stats\` command (which is handled by the game interface).
                ${statsStringForPrompt}

                **Your Role as Dungeon Master (${activeShapeUsername}):**
                1.  **World Weaver:** As ${activeShapeUsername}, create and describe a vivid fantasy world.
                2.  **Storyteller:** As ${activeShapeUsername}, narrate the story, plots, and quests.
                3.  **Character Actor:** As ${activeShapeUsername}, portray NPCs with distinct personalities.
                4.  **Challenge Presenter:** As ${activeShapeUsername}, introduce obstacles, puzzles, and encounters.
                5.  **Arbiter of Actions:** As ${activeShapeUsername}, describe outcomes. When a dice roll is provided, YOU MUST incorporate it AND the player's stats (which you now know contextually) into your narration of success/failure.
                6.  **Maintain Immersion (as DM):** While narrating game events as ${activeShapeUsername}, stay in that character.
                7.  **Guide the Player (as DM):** As ${activeShapeUsername}, conclude narrative responses by asking the Player what they do next.
                8.  **Contextual Dice Rolls (as DM):** As ${activeShapeUsername}, understand that rolls are for actions with uncertain outcomes.
                9.  **Out-of-Character Questions with \`!ask\` (as your Shape self):** If the Player uses \`!ask\`, respond OOC using your original Shape personality, concisely, and do not ask "What do you do next?".

                **Game Start (as DM ${activeShapeUsername}):**
                You are now ${activeShapeUsername}. I am your Player.
                Begin our adventure. Describe the initial setting and the very first situation or challenge my character faces.
                Remember to end by asking me what I do.
                Let the epic tale commence!
                `
            };
            const responseContent = await callShapesApi([initialPromptObject]);
            if (responseContent) {
                const processedContent = processMediaInContent(responseContent);
                scenarioDisplay.innerHTML = processedContent;
                addMessageToChat('shape', processedContent);
            } else {
                scenarioDisplay.innerHTML = "Failed to start the game. Check console for errors and API Key/Shape settings.";
            }
        }
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe;
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
        function renderMarkdown(text) {
            if (typeof text !== 'string') return text;
            let newText = text;
            newText = newText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
            newText = newText.replace(/(?<!\w)\*(?!\s|\*)([^\*\n]+?)\*(?!\w)/g, '<em>$1</em>').replace(/(?<!\w)_(?!\s|_)([^_\n]+?)_(?!\w)/g, '<em>$1</em>');
            newText = newText.replace(/~~(.*?)~~/g, '<del>$1</del>');
            return newText;
        }
        function processMediaInContent(content) {
            if (typeof content !== 'string') return content;
            let processed = content;
            const urlRegex = /(https?:\/\/[^\s<>"]+?\.(png|mp3|jpeg|jpg|gif|wav|ogg))/gi;
            processed = processed.replace(urlRegex, (match, url, extension) => {
                const cleanUrl = escapeHtml(url); 
                const extLower = extension.toLowerCase();
                if (['png', 'jpeg', 'jpg', 'gif'].includes(extLower)) {
                    return `<img src="${cleanUrl}" alt="Image from DM" style="max-width:100%;display:block;margin:10px auto;border-radius:4px;">`;
                } else if (['mp3', 'wav', 'ogg'].includes(extLower)) {
                    return `<audio controls src="${cleanUrl}" style="width:100%;margin:10px 0;">Your browser does not support the audio element. Direct link: <a href="${cleanUrl}" target="_blank">${cleanUrl}</a></audio>`;
                }
                return match; 
            });
            processed = renderMarkdown(processed); 
            return processed;
        }
        async function handleUserAction() {
            if (!activeShapeApiKey || !activeShapeUsername) {
                scenarioDisplay.innerHTML = "Cannot send action: API Key or Active Shape DM not set.";
                addMessageToChat('system', "Error: API Key or Active Shape DM not set."); return;
            }
            if (isApiBusy) { addMessageToChat('system', "DM is still thinking... Please wait."); return; }
            const actionText = playerInput.value.trim();
            if (!actionText) return;
            addMessageToChat('user', actionText, `msg_user_${Date.now()}`); 
            playerInput.value = ''; playerInput.style.height = 'auto'; 
            let promptToShapeContent = actionText;
            let messagesForApi = [];
            let requiresDiceRoll = false;
            const lowerActionText = actionText.toLowerCase();

            if (lowerActionText === '!stats') {
                requiresDiceRoll = false;
                const statsKey = `shapesDnd_playerStats_${activeShapeId}_${currentChannelId}`;
                const storedStats = localStorage.getItem(statsKey);
                if (storedStats) {
                    const playerStats = JSON.parse(storedStats);
                    let statsDisplay = "<strong>Your Character Stats:</strong><br>";
                    for (const [ability, score] of Object.entries(playerStats)) {
                        statsDisplay += `${ability}: ${score}<br>`;
                    }
                    addMessageToChat('system', statsDisplay); 
                } else {
                    addMessageToChat('system', "Player stats not found for current session.");
                }
                promptToShapeContent = null; 
            }
            else if (lowerActionText.startsWith('!ask ')) {
                requiresDiceRoll = false;
                const questionForShape = actionText.substring(5).trim(); 
                promptToShapeContent = `
                The Player has an OOC (Out-Of-Character) question for you, the Shape AI. Player's question: "${questionForShape}"
                IMPORTANT: Respond using your own original base personality as a Shape from shapes.inc, directly and concisely. Do NOT act as DM ${activeShapeUsername} or ask "What do you do next?".
                `;
            }
            else if (lowerActionText.startsWith('!')) { 
                requiresDiceRoll = false; promptToShapeContent = actionText; 
            }
            else if (actionText.endsWith('?')) {
                requiresDiceRoll = false;
                promptToShapeContent = `
                Okay, DM ${activeShapeUsername}. Player asks in-game: "${actionText}"
                Respond as DM ${activeShapeUsername} or NPC. If it implies an action needing a roll, describe and prompt for confirmation. End by asking "What do you do next?".
                `;
            }
            else {
                const actionKeywords = ["i try to","i attempt to","i attack","i cast","i search","i pick","i climb","i jump","i sneak","i persuade","i intimidate","i deceive","i use my","i look for","i investigate","i disable","i open the","i move to"];
                const passiveKeywords = ["i look at","i see","i think","i say","i go to","i walk to","i head towards"];
                let isLikelyAction = actionKeywords.some(keyword => lowerActionText.startsWith(keyword));
                let isLikelyPassive = passiveKeywords.some(keyword => lowerActionText.startsWith(keyword));
                if (isLikelyAction || (!isLikelyPassive && actionText.split(' ').length > 2 && (lowerActionText.includes(" the ") || lowerActionText.includes(" a "))) ) {
                    requiresDiceRoll = true;
                } else {
                    requiresDiceRoll = false; 
                     promptToShapeContent = `
                    Okay, DM ${activeShapeUsername}. Player states/does generally: "${actionText}"
                    Narrate as DM ${activeShapeUsername}. If this could lead to a roll, describe and prompt for specific action. End by asking "What do you do next?".
                    `;
                }
            }

            if (requiresDiceRoll) {
                const diceRoll = await rollDice();
                addMessageToChat('system', `Player rolled a D20: ${diceRoll}`);
                
                const statsKey = `shapesDnd_playerStats_${activeShapeId}_${currentChannelId}`;
                const storedStats = localStorage.getItem(statsKey);
                let playerStatsString = "Player has default/unknown stats.";
                if (storedStats) {
                    const playerStats = JSON.parse(storedStats);
                    playerStatsString = "Player's Current Ability Scores (for your DM context):\n";
                    for (const [ability, score] of Object.entries(playerStats)) {
                        playerStatsString += `${ability}: ${score}\n`;
                    }
                }

                promptToShapeContent = `
                Okay, DM ${activeShapeUsername}. Player action: "${actionText}". Dice roll (D20): ${diceRoll}.
                ${playerStatsString}
                Narrate outcome as DM ${activeShapeUsername}, considering roll AND player stats. Describe scene, consequences. End by asking "What do you do next?".
                `;
            }
            
            if (promptToShapeContent) { 
                messagesForApi.push({ role: "user", content: promptToShapeContent });
                const responseContent = await callShapesApi(messagesForApi);
                if (responseContent) {
                    const processedContent = processMediaInContent(responseContent);
                    scenarioDisplay.innerHTML = processedContent; 
                    addMessageToChat('shape', processedContent, `msg_shape_${Date.now()}`);
                }
            }
        }
        async function rollDice(sides = 20) {
            diceDisplay.textContent = '...'; 
            const spinDuration = 800 + Math.random() * 400; 
            const spinIntervalTime = 70; 
            return new Promise(resolve => {
                const spinInterval = setInterval(() => { diceDisplay.textContent = Math.ceil(Math.random() * sides); }, spinIntervalTime);
                setTimeout(() => {
                    clearInterval(spinInterval);
                    const finalResult = Math.ceil(Math.random() * sides);
                    diceDisplay.textContent = finalResult; resolve(finalResult);
                }, spinDuration);
            });
        }
        async function callShapesApi(messages) {
            const now = Date.now();
            if (now - lastApiCallTime < API_CALL_INTERVAL_MS) {
                const waitTime = API_CALL_INTERVAL_MS - (now - lastApiCallTime);
                apiStatus.textContent = `API: Wait ${Math.ceil(waitTime/1000)}s`;
                addMessageToChat('system', `Rate limit: waiting ${Math.ceil(waitTime/1000)}s...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
            isApiBusy = true; sendActionBtn.disabled = true; sendActionBtn.textContent = 'Thinking...'; 
            apiStatus.textContent = 'API: DM is thinking...';
            try {
                lastApiCallTime = Date.now();
                const response = await fetch(`${SHAPES_API_BASE_URL}chat/completions`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${activeShapeApiKey}`, 'Content-Type': 'application/json', 'X-User-Id': userId, 'X-Channel-Id': currentChannelId || `dnd_game_${activeShapeUsername.replace(/[^a-zA-Z0-9_]/g, '_')}` },
                    body: JSON.stringify({ model: `shapesinc/${activeShapeUsername}`, messages: messages })
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    const errorMessage = errorData.error?.message || errorData.message || `HTTP ${response.status}: ${response.statusText}` || 'Unknown API error';
                    addMessageToChat('system', `API Error: ${errorMessage}`);
                    scenarioDisplay.innerHTML = `An error occurred with the DM: ${errorMessage}. Check console. (Using API Key: ${activeShapeApiKey ? 'Specific' : 'Global'})`; return null;
                }
                const data = await response.json();
                if (data.choices && data.choices[0] && data.choices[0].message) return data.choices[0].message.content;
                else {
                    addMessageToChat('system', `API Error: Received invalid data from DM.`);
                    scenarioDisplay.innerHTML = `The DM gave an unusual response. Check console.`; return null;
                }
            } catch (error) {
                addMessageToChat('system', `Network Error: ${error.message}`);
                scenarioDisplay.innerHTML = `A network error occurred: ${error.message}. Check console.`; return null;
            } finally {
                isApiBusy = false; sendActionBtn.disabled = false; sendActionBtn.textContent = 'Send'; 
                apiStatus.textContent = 'API Ready';
            }
        }
        function addMessageToChat(role, content, id = `msg_${role}_${Date.now()}`) {
            const contentToStore = (role === 'user') ? renderMarkdown(escapeHtml(content)) : (role === 'system' && content.includes("Your Character Stats")) ? content : processMediaInContent(content);
            chatHistory.push({ id, role, content: contentToStore }); 
            renderChatLog(); saveChatHistory(); 
        }
        function renderChatLog() { // This function now correctly wires up the chat action buttons
            chatLog.innerHTML = '';
            chatHistory.forEach(msg => {
                const msgDiv = document.createElement('div');
                msgDiv.classList.add('chat-message');
                msgDiv.classList.add(msg.role === 'user' ? 'user-message' : msg.role === 'shape' ? 'shape-message' : 'system-message');
                msgDiv.dataset.messageId = msg.id;
                let roleDisplay = msg.role === 'user' ? 'You' : (msg.role === 'shape' ? (activeShapeUsername || 'DM') : 'System');
                
                let messageContentHTML = `<span class="message-role">${roleDisplay}:</span> ${msg.content}`; 
                
                let actionsContainer = document.createElement('div');
                actionsContainer.className = 'actions';

                if (msg.role === 'user') {
                    const editBtn = document.createElement('button');
                    editBtn.innerHTML = '📝'; editBtn.title = "Edit Message";
                    editBtn.onclick = () => editChatMessage(msg.id);
                    actionsContainer.appendChild(editBtn);
                }
                if (msg.role === 'shape') {
                    const regenBtn = document.createElement('button');
                    regenBtn.innerHTML = '🔄'; regenBtn.title = "Regenerate Response";
                    regenBtn.onclick = () => regenerateShapeMessage(msg.id);
                    actionsContainer.appendChild(regenBtn);
                }
                const deleteBtn = document.createElement('button'); // Delete for all types
                deleteBtn.innerHTML = '🗑️'; deleteBtn.className = 'danger'; deleteBtn.title = "Delete Message";
                deleteBtn.onclick = () => deleteChatMessage(msg.id);
                actionsContainer.appendChild(deleteBtn);

                msgDiv.innerHTML = messageContentHTML; 
                msgDiv.appendChild(actionsContainer); // Append actions container
                chatLog.appendChild(msgDiv);
            });
            chatLog.scrollTop = chatLog.scrollHeight; 
        }
        function deleteChatMessage(messageId) {
            chatHistory = chatHistory.filter(msg => msg.id !== messageId);
            renderChatLog(); saveChatHistory();
        }
        function editChatMessage(messageId) {
            const messageIndex = chatHistory.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1 || chatHistory[messageIndex].role !== 'user') return;
            
            // To edit, we need the original raw (or at least un-markdowned) content.
            // However, chatHistory stores the HTML content.
            // For a true edit that can then be re-markdowned, we'd need to store original user input.
            // Simple approach: prompt with the current HTML content, then re-escape and re-markdown.
            // This might be confusing if the user sees HTML tags in the prompt.
            // A better way if we stored original text:
            // const originalContent = chatHistory[messageIndex].originalUserInput; 
            // For now, we'll use the stored (potentially HTML) content.
            // This means if they had "**bold**" which became "<strong>bold</strong>", they'd edit "<strong>bold</strong>".
            // To fix this properly, we'd need to store raw user input separately or strip HTML for editing.
            // Given the constraint to only add markdown for user messages, and not change other things,
            // we will prompt with the current (HTML) content. The user can then re-type markdown.
            
            const currentDisplayContent = chatHistory[messageIndex].content; // This is HTML after markdown
            // A temporary workaround for a slightly better edit experience:
            // Create a temporary div, set its innerHTML to the content, then get its textContent.
            // This will strip HTML tags, giving a cleaner text for the prompt.
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentDisplayContent;
            const textToEdit = tempDiv.textContent || tempDiv.innerText || "";

            const newContent = prompt("Edit your message:", textToEdit);

            if (newContent !== null && newContent.trim() !== textToEdit.trim()) {
                // Re-apply markdown to the newly edited content
                chatHistory[messageIndex].content = renderMarkdown(escapeHtml(newContent.trim())); 
                renderChatLog(); saveChatHistory();
                addMessageToChat('system', 'Note: Editing a past message only updates the log locally. The DM will not be aware of this change for past turns.');
            }
        }
        async function regenerateShapeMessage(messageId) {
            const messageIndex = chatHistory.findIndex(msg => msg.id === messageId);
            if (messageIndex > 0 && chatHistory[messageIndex].role === 'shape') {
                let lastUserPromptIndex = -1;
                for (let i = messageIndex - 1; i >= 0; i--) {
                    // Find the raw user message content for the prompt, need to strip HTML if it was markdown.
                    if (chatHistory[i].role === 'user') {
                         // Create a temporary div to get text content from HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = chatHistory[i].content;
                        const userTextContent = tempDiv.textContent || tempDiv.innerText || "";
                        if (!userTextContent.startsWith('!')) {
                            lastUserPromptIndex = i;
                            break;
                        }
                    }
                }
                if (lastUserPromptIndex === -1) { addMessageToChat('system', "Cannot regenerate: No suitable prior user action found."); return; }
                if (isApiBusy) { addMessageToChat('system', "DM is busy. Cannot regenerate now."); return; }
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = chatHistory[lastUserPromptIndex].content;
                const originalUserAction = tempDiv.textContent || tempDiv.innerText || "";


                addMessageToChat('system', `Attempting to regenerate response for your action: "${originalUserAction.substring(0,50)}..."`);
                let diceRollForRegenContext = "";
                let playerStatsStringForRegen = "";
                // Check the message *before* the user's action for a system dice roll message
                if (lastUserPromptIndex > 0 && chatHistory[lastUserPromptIndex -1].role === 'system' && chatHistory[lastUserPromptIndex -1].content.includes("Player rolled a D20:")) {
                    const match = chatHistory[lastUserPromptIndex -1].content.match(/Player rolled a D20: (\d+)/);
                    if (match && match[1]) diceRollForRegenContext = `You previously rolled a D20 and got ${match[1]}. `;
                
                    const statsKey = `shapesDnd_playerStats_${activeShapeId}_${currentChannelId}`;
                    const storedStats = localStorage.getItem(statsKey);
                    if (storedStats) {
                        const playerStats = JSON.parse(storedStats);
                        playerStatsStringForRegen = "Player's Current Ability Scores (for your DM context):\n";
                        for (const [ability, score] of Object.entries(playerStats)) {
                            playerStatsStringForRegen += `${ability}: ${score}\n`;
                        }
                    }
                }
                const regenerationPrompt = `${diceRollForRegenContext}${playerStatsStringForRegen}You took the action: "${originalUserAction}". The Dungeon Master's previous response was not what you wanted. Please provide an alternative narration or outcome for this action. Then, ask what you (the player) want to do next. (Respond as DM ${activeShapeUsername})`;
                const responseContent = await callShapesApi([{ role: "user", content: regenerationPrompt }]);
                if (responseContent) {
                    const processedContent = processMediaInContent(responseContent);
                    chatHistory[messageIndex].content = processedContent; 
                    chatHistory[messageIndex].id = `msg_shape_${Date.now()}`; 
                    renderChatLog(); saveChatHistory();
                    scenarioDisplay.innerHTML = processedContent; 
                } else {
                    addMessageToChat('system', "Failed to regenerate response.");
                }
            } else {
                addMessageToChat('system', "Cannot regenerate this message. (Not a shape response or no preceding user message).");
            }
        }
        playerInput.addEventListener('input', () => {
            playerInput.style.height = 'auto';
            playerInput.style.height = (playerInput.scrollHeight) + 'px';
        });
    </script>
</body>
</html>